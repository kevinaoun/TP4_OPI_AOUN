Exercice 1 :

2) Le répertoire git a été créé, il est masqué. Son adresse est donc "~/TP1/.git". Il contient les dossiers : branches, hooks, info, objects, refs et les fichiers : config, description et HEAD.

3) A l'adresse "~/TP1", j'utilise la commande "touch fichier.txt" pour créer un fichier texte nommé 'fichier'.

4) Message : "Sur la branche master

Aucun commit

Fichiers non suivis:
  (utilisez "git add <fichier>..." pour inclure dans ce qui sera validé)
	fichier.txt
	git.txt

aucune modification ajoutée à la validation mais des fichiers non suivis sont présents (utilisez "git add" pour les suivre)"

Les fichiers ne sont pas sélectionnés et apparaissent en rouge sur le terminal, pour les sélectionner il faut utiliser la commande : "git add <fichier>". Ce serait l'équivalent de mettre les fichiers dans un panier de course.

5) Message : "Sur la branche master

Aucun commit

Modifications qui seront validées :
  (utilisez "git rm --cached <fichier>..." pour désindexer)
	nouveau fichier : fichier.txt
	nouveau fichier : git.txt"
	
Les fichiers sont maintenant sélectionnés et apparaissent en vert sur le termianl. Ils sont dans le panier de course pour poursuivre l'analogie de la question précédente.

6) Message : "[master (root-commit) 24d4bce] Un super Message
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100644 fichier.txt"

7) Message : "Sur la branche master
rien à valider, la copie de travail est propre"

Les 2 fichiers sélectionnés ont bien été commité (les modifications ont été mises à jours et les fichiers enregistrés).

8) La commande "git log -p" permet d'avoir les logs de tous les fichiers commités (les versions précédentes et les modifications apportées). Dans notre cas, on visualise la dernière version du fichier git.txt ainsi que les versions commitées précédement.

9) Lorsqu'un fichier commité est modifié, la commande "git diff" révèle les modifications pas encore commitées avec un + devant les lignes consernées (et en vert).

10) Création d'une clé SSH liée à ssh-agent, puis liaison de celle-ci à GitHub.
Message lors de la commande 'git push -u origin main' : "Counting objects: 100% (6/6), done.
Delta compression using up to 8 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 434 bytes | 434.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:kevinaoun/TP1_OPI.git
 * [new branch]      main -> main
Branch 'main' set up to track remote branch 'main' from 'origin'."

11) On voit notre fichier fichier.txt, dans le dépôt sur GitHub, sur lequel on a bien les modifications effectuées question 9.

12) On modifie le fichier fichier.txt avec la commande "gedit fichier.txt &" ou en y accédant directement.
On ajoute ensuite le fichier avec "git add fichier.txt" afin de le commit avec "git commit -m"Un message"". On push avec "git push" pour publier la mise à jour et la rendre visible sur GitHub.


Exercice 3 :

1) Le caractère '&' permet de lancer un processus en arrière plan.

2) La racine sous GNU/Linux est '/'.

3) 'cd' et 'cd ~' permettent toujours de retourner à la racine de son compte.

4) La commande "ls ~/*" renvoie la liste des fichiers et dossiers en dessous de leur adresse, pour tous les dossiers se situant au dessus du niveau du dossier actuel TP (en regardant l'arbre avec "tree"). 

5) Depuis TP2, on rentre la commande "cp ../TP1/ex2.c ../../../Images/IMG216.jpg .".

6) Il faut "ajouter le chemin du répertoire qui contienta.out dans la variable PATH".

7) La commande "echo "OPI c'est utile.." renvoie le texte entre les guillemets, le caractère '|' prend le retour du 'echo' et l'affecte à la commande "wc -l" dont le paramètre '-l' désigne le nombre de lignes. Ainsi la commande renvoie '1', le nombre de lignes du texte "OPI c'est utile..".

8) Ajouter "2>/dev/null" à la fin de la ligne de commande dans le terminal permet de masquer le message d'erreur.

9) "ps -ef" selectionne tous les process en cours (-e) et les affiche en liste (-f). Le retour de cette commande est injecté dans "grep -c evince" qui recherche les lignes contenant la suite de caractères "evince" et retourne uniquement le nombre de lignes trouvées (-c). Sans le paramètre '-c', la ou les lignes contenant la suite de caractères "evince" seraient renvoyées.
La commande retourne donc le nombre de process actifs contenant la suite de caractères "evince".

10) La commande "chmod g+r,g+w file1" permet d'ajouter (+) les droits de lecture (r) et d'écriture (w) au groupe (g). Une écriture plus conscise serait : "chmod g+rw file1".

11) La commande "cut -f1,5 ../../../liste_main3_2023_2024.csv" retourne le texte du fichier liste_main3_2023_2024.csv en coupant les champs dépassant le 5ème champ (-f1,5) (les champs sont séparés par des tabulations). Dans ce document, toutes les lignes n'ont que 5 champs donc la commande 'cut' les renvoie toutes. Le caractère '|' prend le retour précédant et l'injecte dans "grep Non" qui retourne les lignes contenants la chaine de caractères "Non".
Ainsi la commande cut -f1,5 ../../../liste_main3_2023_2024.csv | grep Non" retourne :
3224931 M.  Thomas  AUBERTIER   Non
3284840 M.  H´eline FAUCHEU Non
4035745 Mme Sara    GRISSIA Non
4210027 Mme Chadha  HASSINE Non
3673118 M.  Francis JEGOU   Non